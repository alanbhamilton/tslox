import fs from 'fs'
import path from 'path'

let args: string[] = process.argv.slice(2)

if (args.length !== 1) {
  console.log('Usage: generate-ast <output directory>')
  process.exit(64)
}

const outputDir: string = args[0]
const baseName = 'Expr'
const outputPath: string = path.resolve(outputDir, `${baseName.toLowerCase()}.ts`)
const writer = fs.createWriteStream(outputPath)
  .on('error', function (err) {
    console.log(err)
    process.exit(64)
  })

// FIXME This feels like it should be a class with common access to the file writer and helper method 'writeln'
defineAst(baseName, [
  'Binary   : left Expr, operator Token, right Expr',
  'Grouping : expression Expr',
  'Literal  : value LiteralObj',
  'Unary    : operator Token, right Expr',
  'Ternary  : cond Expr, truthy Expr, falsy Expr'
])

writer.end()

function defineAst(baseName: string, types: string[]): void {
  writeln('// This file is auto-generated by tools/generate-ast.ts')
  writeln('// or "npm run gen-ast"')
  writeln()
  defineImports(baseName, types)
  defineVisitor(baseName, types)

  writeln(`export abstract class ${baseName} {`)
  writeln(`  abstract accept<R>(visitor: IVisitor<R>): R`)
  writeln(`}`)
  writeln()

  // The AST classes.
  types.forEach(type => {
    const className = type.split(':')[0].trim()
    const fields = type.split(':')[1].trim()
    defineType(baseName, className, fields)
  })
}

function defineImports(baseName: string, types: string[]): void {
  // Extract unique types
  let typesToImport = Array.from(types.reduce((acc: Set<string>, type) => {
    type.split(':')[1].trim()
      .split(', ').map(t => t.split(' ')[1])
      .forEach(t => {
        if (t !== baseName) acc.add(t)
      })
    return acc
  }, new Set<string>()))

  writeln(`import { ${typesToImport.join(', ')} } from './types'`)
  writeln()
}

function defineVisitor(baseName: string, types: string[]): void {
  writeln('export interface IVisitor<R> {')
  types.forEach(type => {
    const className = type.split(':')[0].trim()
    writeln(`  visit${className}${baseName}(${baseName.toLowerCase()}: ${className}): R`)
  })
  writeln('}')
  writeln()
}

function defineType(baseName: string, className: string, fieldList: string): void {
  const fields = fieldList.split(', ').map(field => field.split(' '))

  writeln(`export class ${className} implements ${baseName} {`)
  fields.forEach(field => {
    writeln(`  public ${field.join(': ')}`)
  })
  writeln()
  writeln(`  constructor(${fields.map(f => f.join(': ')).join(', ')}) {`)
  fields.forEach(([name, _type]) => {
    writeln(`    this.${name} = ${name}`)
  })
  writeln('  }')
  writeln()
  writeln('  accept<R>(visitor: IVisitor<R>): R {')
  writeln(`    return visitor.visit${className}${baseName}(this)`)
  writeln('  }')
  writeln('}')
  writeln()
}

function writeln(text = ''): void {
  writer.write(text + '\n')
}
